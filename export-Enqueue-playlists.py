#!/usr/bin/env python
import sys
import os
import sqlite3
import pprint
import re
#import urllib2
import shutil

db_file = '/Users/chadn/Library/Application Support/Enqueue/Enqueue.db'
out_dir = 'playlists/'
erase_files_not_needed = False

skip_playlists   = ('Music', 'Now Playing', 'Duplicate Files', 'Missing Files')
number_errors    = 0
conn             = sqlite3.connect(db_file)
conn.row_factory = sqlite3.Row # allows dictionary access, row['col_name']


def main():
	playlists_info = readDB()
	print pprint.pprint(playlists_info)
	writeFiles(playlists_info)



def readDB():
	playlists_info = {}
	c = conn.cursor()
	c.execute('SELECT * FROM playlists')
	rows_playlists = c.fetchall()
	for row in rows_playlists:
		if row['title'] in skip_playlists:
			continue
		cur_playlist = []
		#print "==> "+ row['title']
		playlist_name = makeUnique(playlists_info, row['title'])
		c2 = conn.cursor()
		for items in c2.execute("SELECT * FROM playlist_items WHERE playlist_id='%d' ORDER BY playlist_index" % row['playlist_id']):
			c3 = conn.cursor()
			c3.execute("SELECT * FROM library WHERE file_id='%s'" % items['file_id'])
			song_info = c3.fetchone()
			cur_playlist.append( song_info )
		playlists_info[ playlist_name ] = cur_playlist
	conn.close()
	return playlists_info

def makeUnique(dictionary, key, suffix=None):
	key2 = key
	if not suffix == None:
		key2 = key + '_v' + str(suffix)
	if key2 not in dictionary:
		return key2
	else:
		if suffix == None:
			suffix = 2
		else:
			suffix += 1
		return makeUnique(dictionary, key, suffix)

def writeFiles(playlists_info):
	global number_errors
	songs2copy = []
	files_needed = []
	copied_bytes = 0
	needed_bytes = 0
	not_needed_bytes = 0
	existing_files = os.listdir(out_dir)
	'''
	#EXTM3U - header - must be first line of file
	#EXTINF - extra info - length (seconds), artist - title
	#EXTINF:157,Zee Avi - Bitter Heart
	bitter_heart.mp3
	'''
	# create playlists (m3u files)
	for playlist_name in playlists_info.keys():
		songs = playlists_info[playlist_name]
		m3u_fn = playlist_name + '.m3u'
		m3u_text = '#EXTM3U - playlist generated by chad from Enqueue: '+ playlist_name + "\n\n"
		for song in songs:
			seconds = str( int(song['time']/1000) )
			m3u_text += "# orig path: "+ song['path'] + "\n"
			m3u_text += "#EXTINF:"+ seconds + ", "+ song['artist'] + " - "+ song['title'] + "\n"
			m3u_text += getFilename(song['path']) + "\n\n"
			songs2copy.append( song['path'] )
		#print m3u_text
		try:
			f = open(out_dir + m3u_fn, 'w')
			f.write(m3u_text)
			f.close()
			copied_bytes += getFileBytes( out_dir + m3u_fn )
			files_needed.append(m3u_fn)
		except Exception,e:
			number_errors += 1
			print "Error: "+ str(e)

	# m3u files are written, now copy all necessary audio files
	for remote_path in songs2copy:
		local_fn = getFilename(remote_path)
		files_needed.append(local_fn)

		copied_bytes += getFileBytes( out_dir + local_fn )

		if local_fn in existing_files:
			print "Not copying, already exists: " + out_dir + local_fn
			continue
		remote_fn = convertPath(remote_path)
		print "    Copying file from: " + remote_fn
		print "    Copying file to  : " + out_dir + local_fn + "\n"
		#shutil.copy2(remote_fn, out_dir + local_fn) # copy2 preserves modification time, etc
		#copied_bytes += getFileBytes( out_dir + local_fn )
		'''
		remote_fo = urllib2.urlopen(path)
		with open(out_dir + local_fn, 'wb') as local_fo:
			print "Copying to "+ local_fn
			shutil.copyfileobj(remote_fo, local_fo)
		'''

	# now remove files out_dir no longer used
	for fn in existing_files:
		if fn in files_needed:
			needed_bytes += getFileBytes( out_dir + fn )
			print "File is needed: " + out_dir + fn
			continue
		#full_file_name = os.path.join(out_dir, local_fn)
	    #if (os.path.isfile(full_file_name)):
		not_needed_bytes += getFileBytes( out_dir + fn )
		if erase_files_not_needed:
			print "TODO: Deleting file no longer needed: " + out_dir + fn

	print "Now there is %s MB needed, and copied %s MB." % (getMB(needed_bytes), getMB(copied_bytes))
	if erase_files_not_needed:
		print "Erased %s MB no longer needed." % getMB(not_needed_bytes)
	else:
		print "Could have erased %s MB no longer needed." % getMB(not_needed_bytes)
	print "Done.  %s error(s)." % number_errors

def getFilename(path):
	global number_errors
	fn = re.sub(r'.*\/', '', path)
	fn = re.sub(r'%20','_', fn)
	# todo: add to file name something to guarantee file name is unique, like
	# size in bytes, modification time, or better yet - sha1 hash of file
	unique_str = '00'
	try:
		statinfo = os.stat( convertPath(path) )
		unique_str = str(statinfo.st_size) # size in bytes is fast and good enough for now
		#unique_str = base36(statinfo.st_size) 
		#print "SIZE: bytes: %d, str: %s\n" % (statinfo.st_size, base36(statinfo.st_size))
	except OSError, e:
		number_errors += 1
		print "Error: "+ str(e)
	fn = re.sub(r'^(.*)(\.[^\.]+)$',\
		lambda m: "%s_%s%s" % (m.group(1), unique_str, m.group(2)), fn)
	return fn

# converts 
def convertPath(path):
	fn = re.sub(r'%20',' ', path)
	fn = re.sub(r'^file://localhost(.*)$',r'\1', fn)
	return fn

def getFileBytes(fn):
	global number_errors
	bytes = 0
	try:
		statinfo = os.stat( fn )
		bytes = statinfo.st_size
	except OSError, e:
		number_errors += 1
		print "Error: "+ str(e)
	return bytes

def getMB(int_x):
	return str(round( int_x / (1024*1024), 1))
	
def base36(int_x):
	BASE36 = '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ' 
	base36_x = ''
	while int_x >= 36:
	    div, mod = divmod(int_x, 36)
	    base36_x = BASE36[mod] + base36_x
	    int_x = int(div)
	return BASE36[int_x] + base36_x

main()


'''
Following from enqueue sql db:

CREATE TABLE playlists (
playlist_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
type INT,	
title TEXT,
rules BLOB,
listViewColumnInfo BLOB,
listViewSortColumn INT DEFAULT 2 NOT NULL,
listViewAscending INT DEFAULT 1 NOT NULL,
albumListViewColumnInfo BLOB,
albumListViewSortColumn INT DEFAULT -1 NOT NULL,
albumListViewAscending INT DEFAULT 1 NOT NULL,
search TEXT DEFAULT '' NOT NULL,
browser_1_attribute INT DEFAULT 0 NOT NULL,
browser_2_attribute INT DEFAULT 0 NOT NULL,
browser_3_attribute INT DEFAULT 2 NOT NULL,
browser_1_selection BLOB,
browser_2_selection BLOB,
browser_3_selection BLOB,
browserInfo BLOB,
libraryViewMode INT DEFAULT 0 NOT NULL );

CREATE TABLE playlist_items (
playlist_item_id INTEGER PRIMARY KEY AUTOINCREMENT,
playlist_id INTEGER NOT NULL,
playlist_index INTEGER NOT NULL,
file_id INTEGER NOT NULL,
UNIQUE(playlist_id,
playlist_index),
FOREIGN KEY(playlist_id) REFERENCES playlists(playlist_id) ON UPDATE CASCADE ON DELETE CASCADE,
FOREIGN KEY(file_id) REFERENCES library(file_id) ON UPDATE CASCADE ON DELETE CASCADE);

CREATE TABLE library (
file_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
path TEXT NOT NULL UNIQUE,
title TEXT NOT NULL DEFAULT '',
artist TEXT NOT NULL DEFAULT '',
album TEXT NOT NULL DEFAULT '',
albumArtist TEXT NOT NULL DEFAULT '',
composer TEXT NOT NULL DEFAULT '',
comments TEXT NOT NULL DEFAULT '',
genre TEXT NOT NULL DEFAULT '',
year INT NOT NULL DEFAULT 0,
trackNumber INT NOT NULL DEFAULT 0,
trackCount INT NOT NULL DEFAULT 0,
discNumber INT NOT NULL DEFAULT 0,
discCount INT NOT NULL DEFAULT 0,
BPM INT NOT NULL DEFAULT 0,
checkSum BLOB NOT NULL DEFAULT x'',
size INT NOT NULL DEFAULT 0,
kind INT NOT NULL DEFAULT 0,
time INT NOT NULL DEFAULT 0,
bitrate INT NOT NULL DEFAULT 0,
channels INT NOT NULL DEFAULT 0,
sampleRate INT NOT NULL DEFAULT 0,
lastModified TEXT NOT NULL DEFAULT '',
albumArt INT NOT NULL DEFAULT 0,
dateAdded TEXT NOT NULL DEFAULT '',
lastPlayed TEXT NOT NULL DEFAULT '',
playCount INT NOT NULL DEFAULT 0,
rating INT NOT NULL DEFAULT 0,
artistAlbumArtist TEXT NOT NULL DEFAULT '' ,
lyrics TEXT NOT NULL DEFAULT '',
compilation INT NOT NULL DEFAULT 0);

'''



